[BASICS]
id = 1
const = a -> b -> a
selfCall = a -> a a
recursive = a -> selfCall `id (b -> a `id b b)
rev = a -> b -> b a
comp = a -> b -> c -> a `id b c
ignore = 0
[n(Function) 1 ought to be the same as function]
nRev = n -> n (next -> x -> rev x `comp next) id
nComp = (nRev 2) (next -> f -> g -> x -> next f (g x)) id
[TODO nIgnore]
[TODO different kind of nComp where it's f -> g -> a1 -> a2 -> ... -> an -> f (g a1 a2 ... an), and probably get rid of current nComp]
[EITHER]
left = x -> f -> g -> f x
right = x -> f -> g -> g x
bindEither = nRev 2 left
[MAYBE]
just = left
none = ignore
bindMaybe = rev none `comp nRev 2
[BOOL]
true = const
false = ignore
notBool = nRev 2 false true
andBool = rev false `comp nRev 2
orBool = nRev 2 true
[TODO more bool stuff]
[NAT]
incNat = n -> f -> n f `comp f
addNat = rev incNat
[TODO maybe more nat stuff]
[TUP]
tup = nRev 2
fstTup = rev const
sndTup = rev ignore
[LIST]
consList = head -> rest -> f -> const `id f head rest
emptyList = ignore
mapList = f -> nRev 2 (consList `comp f) emptyList
filterList = f -> nRev 2 (head -> f head (consList head) id) emptyList
concatList = rev consList
bindList = a -> b -> mapList b a concatList emptyList
