[basic functions]
id = 1
then = a -> b -> c -> b `id a c
combineThen = a -> b -> c -> d -> b `id a c d
const = a -> b -> a
rev = a -> b -> b a
in = rev
revRev = a -> b -> rev a `then rev b
selfCall = a -> a a
recursive = a -> selfCall (b -> a `id b b)
[bool]
true = const
false = 0
and = a -> b -> a b a
or = a -> b -> a a b
not = revRev false true
nand = and `combineThen not
nor = or `combineThen not
xor = a -> b -> or a b `and nand a b
xnor = xor `combineThen not
[either]
left = a -> b -> const `id b a
right = a -> b -> c -> c a
callEither = a -> b -> b a a
[maybe]
just = left
none = false
callMaybe = a -> revRev (a `then just) none
bindMaybe = a -> revRev a none
[tup]
,T = revRev
headTup = rev true
tailTup = rev false
[num]
++Num = a -> b -> b `then a b
+Num = rev ++Num
*Num = a -> +Num a `revRev 0
^Num = rev
shiftIncrTup _= tailTup `then a -> a `,T ++Num a
--Num = revRev shiftIncrTup (0 `,T 0) `then headTup
-Num = revRev --Num
=0 _= const false `revRev true
<=Num = -Num `combineThen =0
>Num = <=Num `combineThen not
=Num = a -> b -> <=Num a b `and <=Num b a
>=Num = a -> b -> =Num a b `or >Num a b
<Num = >=Num `combineThen not
[list]
,L = ,T `combineThen just
headList = callMaybe headTup
tailList = callMaybe tailTup `then revRev id 0
Maybe->List = callMaybe (a -> a `,T 0)
@List = a -> b -> headList `id b tailList a
[...]
[IO]
inp = left `then left
otp = ,T `combineThen ,T `combineThen right `then left
fork = ,T `combineThen just `then right
stop = right false
