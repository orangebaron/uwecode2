[BASICS]
id = 1
const = a -> b -> a
selfCall = a -> a a
recursive = a -> selfCall `id (b -> a `id b b)
rev = a -> b -> b a
comp = a -> b -> c -> a `id b c
ignore = 0
[n(Function) 1 ought to be the same as function]
nRev = n -> n (next -> x -> rev x `comp next) id
nComp = (nRev 2) (next -> f -> g -> x -> next f (g x)) id
[TODO nIgnore]
[TODO different kind of nComp where it's f -> g -> a1 -> a2 -> ... -> an -> f (g a1 a2 ... an), and probably get rid of current nComp]
[EITHER]
left = x -> f -> g -> f x
right = x -> f -> g -> g x
bindEither = nRev 2 left
[MAYBE]
just = left
none = ignore
bindMaybe = a -> nRev 2 a none
[BOOL]
true = const
false = none
notBool = nRev 2 false true
andBool = bindMaybe
orBool = nRev 2 true
[TODO more bool stuff]
[NAT]
incNat = n -> f -> n f `comp f
addNat = rev incNat
[TODO maybe more nat stuff]
[TUP]
tup = nRev 2
fstTup = rev const
sndTup = rev ignore
[LIST]
consList = head -> rest -> f -> const `id f head rest
emptyList = ignore
reduceList = nRev 2
mapList = f -> reduceList (consList `comp f) emptyList
reduceList = f -> reduceList (head -> f head (consList head) id) emptyList
